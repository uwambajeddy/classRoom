import _Symbol$toStringTag2 from "@babel/runtime-corejs3/core-js-stable/symbol/to-string-tag";
import _entriesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/entries";
import _keysInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/keys";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/asyncToGenerator";
import _Map from "@babel/runtime-corejs3/core-js-stable/map";
import _Symbol$asyncIterator2 from "@babel/runtime-corejs3/core-js-stable/symbol/async-iterator";
import _Symbol$iterator2 from "@babel/runtime-corejs3/core-js-stable/symbol/iterator";
import _Array$from from "@babel/runtime-corejs3/core-js-stable/array/from";
import _valuesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/values";
import _repeatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/repeat";
import _defineProperty from "@babel/runtime-corejs3/helpers/defineProperty";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _wrapAsyncGenerator from "@babel/runtime-corejs3/helpers/wrapAsyncGenerator";
import _awaitAsyncGenerator from "@babel/runtime-corejs3/helpers/awaitAsyncGenerator";
import _asyncIterator from "@babel/runtime-corejs3/helpers/asyncIterator";
import _asyncGeneratorDelegate from "@babel/runtime-corejs3/helpers/asyncGeneratorDelegate";
import stream from "stream";
import path from "path";
import mimes from "mime-types";
import invariant from "@octetstream/invariant";
import getStreamIterator from "./util/getStreamIterator";
import StreamIterator from "./util/StreamIterator";
import isFunction from "./util/isFunction";
import getLength from "./util/getLength";
import isString from "./util/isString";
import isObject from "./util/isObject";
import isBuffer from "./util/isBuffer";
import isStream from "./util/isStream";
import boundary from "./util/boundary";
import getType from "./util/getType";
import isBlob from "./util/isBlob";
import concat from "./util/concat";
import bind from "./util/bind";
const isArray = _Array$isArray;
/**
 * FormData implementation for Node.js environments.
 * Bult over Readable stream and async generators.
 * Can be used to communicate between servers with multipart/form-data format.
 *
 * @api public
 */

var _Symbol$toStringTag = _Symbol$toStringTag2;
var _Symbol$iterator = _Symbol$iterator2;
var _Symbol$asyncIterator = _Symbol$asyncIterator2;

class FormData {
  /**
   * Check if given value is instance of FormData
   * Note: This method is not a part of client-side FormData interface.
   *
   * @param {any} value
   *
   * @return {boolean}
   *
   * @public
   */
  static isFormData(value) {
    return value instanceof FormData;
  }
  /**
   * @param {array} fields – an optional FormData initial fields.
   *   Each initial field should be passed as a collection of the objects
   *   with "name", "value" and "filename" props.
   *   See the FormData#append for more info about the available format.
   */


  constructor(entries = null) {
    _defineProperty(this, "__getMime", filename => mimes.lookup(filename) || this.__defaultContentType);

    _defineProperty(this, "__getFooter", () => {
      var _context;

      return concat([this.__dashes, this.__boundary, this.__dashes, _repeatInstanceProperty(_context = this.__carriage).call(_context, 2)]);
    });

    _defineProperty(this, "__read", () => {
      const onFulfilled = ({
        done,
        value
      }) => {
        if (done) {
          return this.__stream.push(null);
        }

        this.__stream.push(isBuffer(value) ? value : Buffer.from(String(value)));
      };

      const onRejected = err => this.__stream.emit("error", err);

      this.__curr.next().then(onFulfilled).catch(onRejected);
    });

    _defineProperty(this, "__appendFromInitialFields", fields => {
      for (const field of fields) {
        if (isObject(field) && !isArray(field)) {
          this.append(field.name, field.value, field.filename);
        }
      }
    });

    _defineProperty(this, "append", (name, value, filename) => this.__setField(name, value, filename, 1));

    _defineProperty(this, "set", (name, value, filename) => this.__setField(name, value, filename));

    _defineProperty(this, "has", name => this.__content.has(name));

    _defineProperty(this, "get", name => {
      const field = this.__content.get(name);

      if (!field) {
        return undefined;
      }

      return _valuesInstanceProperty(field)[0];
    });

    _defineProperty(this, "getAll", name => {
      const field = this.__content.get(name);

      return field ? _Array$from(_valuesInstanceProperty(field)) : [];
    });

    _defineProperty(this, "delete", name => void this.__content.delete(name));

    _defineProperty(this, "forEach", (fn, ctx = null) => {
      for (const [name, value] of this) {
        fn.call(ctx, value, name, this);
      }
    });

    bind([_Symbol$iterator2, _Symbol$asyncIterator2, "toString", "inspect", "keys", "values", "entries"], this);
    this.__carriage = "\r\n";
    this.__defaultContentType = "application/octet-steam";
    this.__dashes = "--";
    this.__boundary = concat(["NodeJSFormDataStream", boundary()]);
    this.__content = new _Map();
    this.__curr = this.__getField();
    this.__stream = new stream.Readable({
      read: this.__read
    });

    if (isArray(entries)) {
      this.__appendFromInitialFields(entries);
    }
  }
  /**
   * @private
   */


  /**
   * @private
   */
  __getHeader(name, filename) {
    var _context2;

    const head = [this.__dashes, this.__boundary, this.__carriage, "Content-Disposition: form-data; ", `name="${name}"`];

    if (filename) {
      head.push(`; filename="${filename}"${this.__carriage}`);
      head.push(`Content-Type: "${this.__getMime(filename)}"`);
    }

    head.push(_repeatInstanceProperty(_context2 = this.__carriage).call(_context2, 2));
    return concat(head);
  }
  /**
   * @private
   */


  /**
   * Get each field from internal Map
   *
   * @private
   */
  __getField() {
    var _this = this;

    return _wrapAsyncGenerator(function* () {
      for (const [name, {
        values,
        filename
      }] of _this.__content) {
        // Set field header
        yield _this.__getHeader(name, filename);

        for (const value of values) {
          if (isBlob(value)) {
            yield* _asyncGeneratorDelegate(_asyncIterator(getStreamIterator(value.stream())), _awaitAsyncGenerator);
          } else if (isStream(value)) {
            // Read the stream content
            yield* _asyncGeneratorDelegate(_asyncIterator(getStreamIterator(value)), _awaitAsyncGenerator);
          } else {
            yield value;
          }
        } // Add trailing carriage


        yield _this.__carriage;
      } // Add a footer when all fields ended


      yield _this.__getFooter();
    })();
  }
  /**
   * Read values from internal storage and push it to the internal stream
   *
   * @return {void}
   *
   * @private
   */


  /**
   * Appends a new value onto an existing key inside a FormData object,
   * or adds the key if it does not already exist.
   *
   * @param {string} name – The name of the field whose data
   *   is contained in value
   *
   * @param {any} value – The field value. You can pass any primitive type
   *   (including null and undefined), Buffer or Readable stream.
   *   Note that Arrays and Object will be converted to string
   *   by using String function.
   *
   * @param {string} [filename = undefined] A filename of given field.
   *   Can be added only for Buffer and Readable
   *
   * @return {void}
   *
   * @private
   */
  __setField(name, value, filename, append = false) {
    invariant(!isString(name), TypeError, "Field name should be a string. Received %s", getType(name));
    invariant(filename && !isString(filename), TypeError, "Filename should be a string (if passed). Received %s", getType(filename)); // Getting a filename for Buffer and Readable values

    if (isBuffer(value) && filename) {
      filename = path.basename(filename);
    } else if (isBlob(value)) {
      filename = path.basename(value.name || filename);
    } else if (isStream(value) && (value.path || filename)) {
      // Readable stream which created from fs.createReadStream
      // have a "path" property. So, we can get a "filename"
      // from the stream itself.
      filename = path.basename(value.path || filename);
    } else {
      // TODO: Add an error here if the filename prop is set to fit
      // browser implementations behaviour
      filename = undefined;
    }

    append = Boolean(append);

    if (!(isStream(value) || isBuffer(value) || isBlob(value))) {
      value = String(value);
    }

    const field = this.__content.get(name); // Set a new field if given name is not exists


    if (!field) {
      return void this.__content.set(name, {
        append,
        filename,
        values: [value]
      });
    } // Replace a value of the existing field if "set" called


    if (!append) {
      return void this.__content.set(name, {
        append,
        filename,
        values: [value]
      });
    } // Do nothing if the field has been created from .set()


    if (!field.append) {
      return undefined;
    } // Append a new value to the existing field


    _valuesInstanceProperty(field).push(value);

    this.__content.set(name, field);
  }
  /**
   * Returns boundary string
   *
   * @return {string}
   *
   * @public
   */


  get boundary() {
    return this.__boundary;
  }
  /**
   * Returns headers for multipart/form-data
   */


  get headers() {
    return {
      "Content-Type": concat(["multipart/form-data; ", "boundary=", this.boundary])
    };
  }
  /**
   * Returns the internal stream
   *
   * @return {stream.Readable}
   *
   * @public
   */


  get stream() {
    return this.__stream;
  }
  /**
   * Returns computed length of the FormData content.
   * If data contains stream.Readable field(s),
   * the method will always return undefined.
   *
   * @return {number}
   */


  getComputedLength() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      if (_this2.__content.size === 0) {
        return 0;
      }

      let length = 0;
      const carriageLength = Buffer.from(_this2.__carriage).length;

      for (const [name, {
        filename,
        values
      }] of _this2.__content) {
        length += Buffer.from(_this2.__getHeader(name, filename)).length;

        for (const value of values) {
          const valueLength = yield getLength(value);

          if (valueLength == null) {
            return undefined;
          }

          length += Number(valueLength);
        }

        length += carriageLength;
      }

      length += Buffer.from(_this2.__getFooter()).length;
      return length;
    })();
  }
  /**
   * Appends a new value onto an existing key inside a FormData object,
   * or adds the key if it does not already exist.
   *
   * @param {string} name – The name of the field whose data
   *   is contained in value
   *
   * @param {any} value – The field value. You can pass any primitive type
   *   (including null and undefined), Buffer or Readable stream.
   *   Note that Arrays and Object will be converted to string
   *   by using String function.
   *
   * @param {string} [filename = undefined] A filename of given field.
   *   Can be added only for Buffer and Readable
   *
   * @return {void}
   *
   * @public
   */


  /**
   * Returns a string representation of the FormData
   *
   * @return {string}
   */
  toString() {
    return "[object FormData]";
  }
  /**
   * Returns a string representation of the FormData
   *
   * @return {string}
   */


  inspect() {
    return "FormData";
  }

  get [_Symbol$toStringTag]() {
    return "FormData";
  }
  /**
   * @return {IterableIterator<string>}
   */


  *keys() {
    for (const key of _keysInstanceProperty(_context3 = this.__content).call(_context3)) {
      var _context3;

      yield key;
    }
  }
  /**
   * @return {IterableIterator<[string, any]>}
   */


  *entries() {
    for (const name of _keysInstanceProperty(_context4 = this).call(_context4)) {
      var _context4;

      const values = this.getAll(name); // Yield each value of a field, like browser-side FormData does.

      for (const value of values) {
        yield [name, value];
      }
    }
  }
  /**
   * @return {IterableIterator<any>}
   */


  *values() {
    for (const [, values] of this) {
      yield values;
    }
  }
  /**
   * Executes a given callback for each field of the FormData instance
   *
   * @param {function} fn – Function to execute for each element,
   *   taking three arguments:
   *     + {any} value – A value(s) of the current field.
   *     + {string} – Name of the current field.
   *     + {FormData} fd – The FormData instance that forEach
   *       is being applied to
   *
   * @param {any} [ctx = null]
   *
   * @public
   */


  /**
   * @return {IterableIterator<[string, any]>}
   */
  [_Symbol$iterator]() {
    var _context5;

    return _entriesInstanceProperty(_context5 = this).call(_context5);
  }
  /**
   * This method allows to read a content from internal stream
   * using async generators and for-await-of APIs
   *
   * @return {IterableIterator<Promise<Buffer>>}
   *
   * @public
   */


  [_Symbol$asyncIterator]() {
    if (isFunction(this.stream[_Symbol$asyncIterator2])) {
      return this.stream[_Symbol$asyncIterator2]();
    }

    return new StreamIterator(this.stream);
  }

}

export default FormData;