"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _toStringTag = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/symbol/to-string-tag"));

var _entries = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/entries"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/keys"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/asyncToGenerator"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/map"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/symbol/async-iterator"));

var _iterator = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/symbol/iterator"));

var _from = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/from"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/values"));

var _repeat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/repeat"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/wrapAsyncGenerator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/awaitAsyncGenerator"));

var _asyncIterator3 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/asyncIterator"));

var _asyncGeneratorDelegate2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/asyncGeneratorDelegate"));

var _stream = _interopRequireDefault(require("stream"));

var _path = _interopRequireDefault(require("path"));

var _mimeTypes = _interopRequireDefault(require("mime-types"));

var _invariant = _interopRequireDefault(require("@octetstream/invariant"));

var _getStreamIterator = _interopRequireDefault(require("./util/getStreamIterator"));

var _StreamIterator = _interopRequireDefault(require("./util/StreamIterator"));

var _isFunction = _interopRequireDefault(require("./util/isFunction"));

var _getLength = _interopRequireDefault(require("./util/getLength"));

var _isString = _interopRequireDefault(require("./util/isString"));

var _isObject = _interopRequireDefault(require("./util/isObject"));

var _isBuffer = _interopRequireDefault(require("./util/isBuffer"));

var _isStream = _interopRequireDefault(require("./util/isStream"));

var _boundary = _interopRequireDefault(require("./util/boundary"));

var _getType = _interopRequireDefault(require("./util/getType"));

var _isBlob = _interopRequireDefault(require("./util/isBlob"));

var _concat = _interopRequireDefault(require("./util/concat"));

var _bind = _interopRequireDefault(require("./util/bind"));

const isArray = _isArray.default;
/**
 * FormData implementation for Node.js environments.
 * Bult over Readable stream and async generators.
 * Can be used to communicate between servers with multipart/form-data format.
 *
 * @api public
 */

var _Symbol$toStringTag = _toStringTag.default;
var _Symbol$iterator = _iterator.default;
var _Symbol$asyncIterator = _asyncIterator2.default;

class FormData {
  /**
   * Check if given value is instance of FormData
   * Note: This method is not a part of client-side FormData interface.
   *
   * @param {any} value
   *
   * @return {boolean}
   *
   * @public
   */
  static isFormData(value) {
    return value instanceof FormData;
  }
  /**
   * @param {array} fields – an optional FormData initial fields.
   *   Each initial field should be passed as a collection of the objects
   *   with "name", "value" and "filename" props.
   *   See the FormData#append for more info about the available format.
   */


  constructor(entries = null) {
    (0, _defineProperty2.default)(this, "__getMime", filename => _mimeTypes.default.lookup(filename) || this.__defaultContentType);
    (0, _defineProperty2.default)(this, "__getFooter", () => {
      var _context;

      return (0, _concat.default)([this.__dashes, this.__boundary, this.__dashes, (0, _repeat.default)(_context = this.__carriage).call(_context, 2)]);
    });
    (0, _defineProperty2.default)(this, "__read", () => {
      const onFulfilled = ({
        done,
        value
      }) => {
        if (done) {
          return this.__stream.push(null);
        }

        this.__stream.push((0, _isBuffer.default)(value) ? value : Buffer.from(String(value)));
      };

      const onRejected = err => this.__stream.emit("error", err);

      this.__curr.next().then(onFulfilled).catch(onRejected);
    });
    (0, _defineProperty2.default)(this, "__appendFromInitialFields", fields => {
      for (const field of fields) {
        if ((0, _isObject.default)(field) && !isArray(field)) {
          this.append(field.name, field.value, field.filename);
        }
      }
    });
    (0, _defineProperty2.default)(this, "append", (name, value, filename) => this.__setField(name, value, filename, 1));
    (0, _defineProperty2.default)(this, "set", (name, value, filename) => this.__setField(name, value, filename));
    (0, _defineProperty2.default)(this, "has", name => this.__content.has(name));
    (0, _defineProperty2.default)(this, "get", name => {
      const field = this.__content.get(name);

      if (!field) {
        return undefined;
      }

      return (0, _values.default)(field)[0];
    });
    (0, _defineProperty2.default)(this, "getAll", name => {
      const field = this.__content.get(name);

      return field ? (0, _from.default)((0, _values.default)(field)) : [];
    });
    (0, _defineProperty2.default)(this, "delete", name => void this.__content.delete(name));
    (0, _defineProperty2.default)(this, "forEach", (fn, ctx = null) => {
      for (const [name, value] of this) {
        fn.call(ctx, value, name, this);
      }
    });
    (0, _bind.default)([_iterator.default, _asyncIterator2.default, "toString", "inspect", "keys", "values", "entries"], this);
    this.__carriage = "\r\n";
    this.__defaultContentType = "application/octet-steam";
    this.__dashes = "--";
    this.__boundary = (0, _concat.default)(["NodeJSFormDataStream", (0, _boundary.default)()]);
    this.__content = new _map.default();
    this.__curr = this.__getField();
    this.__stream = new _stream.default.Readable({
      read: this.__read
    });

    if (isArray(entries)) {
      this.__appendFromInitialFields(entries);
    }
  }
  /**
   * @private
   */


  /**
   * @private
   */
  __getHeader(name, filename) {
    var _context2;

    const head = [this.__dashes, this.__boundary, this.__carriage, "Content-Disposition: form-data; ", `name="${name}"`];

    if (filename) {
      head.push(`; filename="${filename}"${this.__carriage}`);
      head.push(`Content-Type: "${this.__getMime(filename)}"`);
    }

    head.push((0, _repeat.default)(_context2 = this.__carriage).call(_context2, 2));
    return (0, _concat.default)(head);
  }
  /**
   * @private
   */


  /**
   * Get each field from internal Map
   *
   * @private
   */
  __getField() {
    var _this = this;

    return (0, _wrapAsyncGenerator2.default)(function* () {
      for (const [name, {
        values,
        filename
      }] of _this.__content) {
        // Set field header
        yield _this.__getHeader(name, filename);

        for (const value of values) {
          if ((0, _isBlob.default)(value)) {
            yield* (0, _asyncGeneratorDelegate2.default)((0, _asyncIterator3.default)((0, _getStreamIterator.default)(value.stream())), _awaitAsyncGenerator2.default);
          } else if ((0, _isStream.default)(value)) {
            // Read the stream content
            yield* (0, _asyncGeneratorDelegate2.default)((0, _asyncIterator3.default)((0, _getStreamIterator.default)(value)), _awaitAsyncGenerator2.default);
          } else {
            yield value;
          }
        } // Add trailing carriage


        yield _this.__carriage;
      } // Add a footer when all fields ended


      yield _this.__getFooter();
    })();
  }
  /**
   * Read values from internal storage and push it to the internal stream
   *
   * @return {void}
   *
   * @private
   */


  /**
   * Appends a new value onto an existing key inside a FormData object,
   * or adds the key if it does not already exist.
   *
   * @param {string} name – The name of the field whose data
   *   is contained in value
   *
   * @param {any} value – The field value. You can pass any primitive type
   *   (including null and undefined), Buffer or Readable stream.
   *   Note that Arrays and Object will be converted to string
   *   by using String function.
   *
   * @param {string} [filename = undefined] A filename of given field.
   *   Can be added only for Buffer and Readable
   *
   * @return {void}
   *
   * @private
   */
  __setField(name, value, filename, append = false) {
    (0, _invariant.default)(!(0, _isString.default)(name), TypeError, "Field name should be a string. Received %s", (0, _getType.default)(name));
    (0, _invariant.default)(filename && !(0, _isString.default)(filename), TypeError, "Filename should be a string (if passed). Received %s", (0, _getType.default)(filename)); // Getting a filename for Buffer and Readable values

    if ((0, _isBuffer.default)(value) && filename) {
      filename = _path.default.basename(filename);
    } else if ((0, _isBlob.default)(value)) {
      filename = _path.default.basename(value.name || filename);
    } else if ((0, _isStream.default)(value) && (value.path || filename)) {
      // Readable stream which created from fs.createReadStream
      // have a "path" property. So, we can get a "filename"
      // from the stream itself.
      filename = _path.default.basename(value.path || filename);
    } else {
      // TODO: Add an error here if the filename prop is set to fit
      // browser implementations behaviour
      filename = undefined;
    }

    append = Boolean(append);

    if (!((0, _isStream.default)(value) || (0, _isBuffer.default)(value) || (0, _isBlob.default)(value))) {
      value = String(value);
    }

    const field = this.__content.get(name); // Set a new field if given name is not exists


    if (!field) {
      return void this.__content.set(name, {
        append,
        filename,
        values: [value]
      });
    } // Replace a value of the existing field if "set" called


    if (!append) {
      return void this.__content.set(name, {
        append,
        filename,
        values: [value]
      });
    } // Do nothing if the field has been created from .set()


    if (!field.append) {
      return undefined;
    } // Append a new value to the existing field


    (0, _values.default)(field).push(value);

    this.__content.set(name, field);
  }
  /**
   * Returns boundary string
   *
   * @return {string}
   *
   * @public
   */


  get boundary() {
    return this.__boundary;
  }
  /**
   * Returns headers for multipart/form-data
   */


  get headers() {
    return {
      "Content-Type": (0, _concat.default)(["multipart/form-data; ", "boundary=", this.boundary])
    };
  }
  /**
   * Returns the internal stream
   *
   * @return {stream.Readable}
   *
   * @public
   */


  get stream() {
    return this.__stream;
  }
  /**
   * Returns computed length of the FormData content.
   * If data contains stream.Readable field(s),
   * the method will always return undefined.
   *
   * @return {number}
   */


  getComputedLength() {
    var _this2 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      if (_this2.__content.size === 0) {
        return 0;
      }

      let length = 0;
      const carriageLength = Buffer.from(_this2.__carriage).length;

      for (const [name, {
        filename,
        values
      }] of _this2.__content) {
        length += Buffer.from(_this2.__getHeader(name, filename)).length;

        for (const value of values) {
          const valueLength = yield (0, _getLength.default)(value);

          if (valueLength == null) {
            return undefined;
          }

          length += Number(valueLength);
        }

        length += carriageLength;
      }

      length += Buffer.from(_this2.__getFooter()).length;
      return length;
    })();
  }
  /**
   * Appends a new value onto an existing key inside a FormData object,
   * or adds the key if it does not already exist.
   *
   * @param {string} name – The name of the field whose data
   *   is contained in value
   *
   * @param {any} value – The field value. You can pass any primitive type
   *   (including null and undefined), Buffer or Readable stream.
   *   Note that Arrays and Object will be converted to string
   *   by using String function.
   *
   * @param {string} [filename = undefined] A filename of given field.
   *   Can be added only for Buffer and Readable
   *
   * @return {void}
   *
   * @public
   */


  /**
   * Returns a string representation of the FormData
   *
   * @return {string}
   */
  toString() {
    return "[object FormData]";
  }
  /**
   * Returns a string representation of the FormData
   *
   * @return {string}
   */


  inspect() {
    return "FormData";
  }

  get [_Symbol$toStringTag]() {
    return "FormData";
  }
  /**
   * @return {IterableIterator<string>}
   */


  *keys() {
    for (const key of (0, _keys.default)(_context3 = this.__content).call(_context3)) {
      var _context3;

      yield key;
    }
  }
  /**
   * @return {IterableIterator<[string, any]>}
   */


  *entries() {
    for (const name of (0, _keys.default)(_context4 = this).call(_context4)) {
      var _context4;

      const values = this.getAll(name); // Yield each value of a field, like browser-side FormData does.

      for (const value of values) {
        yield [name, value];
      }
    }
  }
  /**
   * @return {IterableIterator<any>}
   */


  *values() {
    for (const [, values] of this) {
      yield values;
    }
  }
  /**
   * Executes a given callback for each field of the FormData instance
   *
   * @param {function} fn – Function to execute for each element,
   *   taking three arguments:
   *     + {any} value – A value(s) of the current field.
   *     + {string} – Name of the current field.
   *     + {FormData} fd – The FormData instance that forEach
   *       is being applied to
   *
   * @param {any} [ctx = null]
   *
   * @public
   */


  /**
   * @return {IterableIterator<[string, any]>}
   */
  [_Symbol$iterator]() {
    var _context5;

    return (0, _entries.default)(_context5 = this).call(_context5);
  }
  /**
   * This method allows to read a content from internal stream
   * using async generators and for-await-of APIs
   *
   * @return {IterableIterator<Promise<Buffer>>}
   *
   * @public
   */


  [_Symbol$asyncIterator]() {
    if ((0, _isFunction.default)(this.stream[_asyncIterator2.default])) {
      return this.stream[_asyncIterator2.default]();
    }

    return new _StreamIterator.default(this.stream);
  }

}

var _default = FormData;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;