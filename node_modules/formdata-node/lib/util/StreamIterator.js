"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _asyncIterator = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/symbol/async-iterator"));

var _symbol = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/symbol"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/asyncToGenerator"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));

var _nextTick = _interopRequireDefault(require("./nextTick"));

var _Symbol$asyncIterator = _asyncIterator.default;

/**
 * StreamIterator helps with getting data from a Readable stream using an
 * async iterator
 *
 * @api private
 */
class StreamIterator {
  /**
   * @param {stream.Readable} stream
   */
  constructor(stream) {
    var _this = this;

    (0, _defineProperty2.default)(this, "__setState", state => void (this.__state = state));
    (0, _defineProperty2.default)(this, "__isState", state => this.__state === state);
    (0, _defineProperty2.default)(this, "__isPendingState", () => this.__isState(this.__states.pending));
    (0, _defineProperty2.default)(this, "__isEndState", () => {
      // Temporarily hack while waiting for new public APIs of streams:
      // See for more info: https://github.com/nodejs/node/issues/445
      // eslint-disable-next-line
      const state = this.__stream._readableState;
      return state.ended && state.endEmitted;
    });
    (0, _defineProperty2.default)(this, "__isErrorState", () => this.__isState(this.__states.error));
    (0, _defineProperty2.default)(this, "__onError", err => {
      this.__error = err;

      this.__setState(this.__states.error);
    });
    (0, _defineProperty2.default)(this, "__ensureRead", () => new _promise.default(resolve => {
      const fulfill = () => resolve(this.__setState(this.__states.read));

      this.__stream.once("readable", fulfill);
    }));
    (0, _defineProperty2.default)(this, "next",
    /*#__PURE__*/
    (0, _asyncToGenerator2.default)(function* () {
      while (true) {
        yield (0, _nextTick.default)();

        if (_this.__isErrorState()) {
          throw _this.__error;
        } // Ensure of a Readable ending


        if (_this.__isEndState()) {
          return {
            value: undefined,
            done: true
          };
        } // Set the "readable" event listener (using once method)
        // and wait for the event emitting


        if (_this.__isPendingState()) {
          yield _this.__ensureRead();
          continue;
        }

        const value = _this.__stream.read(); // Back to the "pending" state if given value is nullish


        if (value == null) {
          _this.__setState(_this.__states.pending);

          continue;
        }

        return {
          value,
          done: false
        };
      }
    }));
    this.__stream = stream;
    this.__states = {
      pending: (0, _symbol.default)("pending"),
      read: (0, _symbol.default)("read"),
      error: (0, _symbol.default)("error")
    };
    this.__state = this.__states.pending;
    this.__error = null;

    this.__stream.on("error", this.__onError);
  }

  [_Symbol$asyncIterator]() {
    return this;
  }

}

var _default = StreamIterator;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;