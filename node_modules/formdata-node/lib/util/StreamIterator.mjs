import _Symbol$asyncIterator2 from "@babel/runtime-corejs3/core-js-stable/symbol/async-iterator";
import _Symbol from "@babel/runtime-corejs3/core-js-stable/symbol";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/asyncToGenerator";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _defineProperty from "@babel/runtime-corejs3/helpers/defineProperty";
import nextTick from "./nextTick";
/**
 * StreamIterator helps with getting data from a Readable stream using an
 * async iterator
 *
 * @api private
 */

var _Symbol$asyncIterator = _Symbol$asyncIterator2;

class StreamIterator {
  /**
   * @param {stream.Readable} stream
   */
  constructor(stream) {
    var _this = this;

    _defineProperty(this, "__setState", state => void (this.__state = state));

    _defineProperty(this, "__isState", state => this.__state === state);

    _defineProperty(this, "__isPendingState", () => this.__isState(this.__states.pending));

    _defineProperty(this, "__isEndState", () => {
      // Temporarily hack while waiting for new public APIs of streams:
      // See for more info: https://github.com/nodejs/node/issues/445
      // eslint-disable-next-line
      const state = this.__stream._readableState;
      return state.ended && state.endEmitted;
    });

    _defineProperty(this, "__isErrorState", () => this.__isState(this.__states.error));

    _defineProperty(this, "__onError", err => {
      this.__error = err;

      this.__setState(this.__states.error);
    });

    _defineProperty(this, "__ensureRead", () => new _Promise(resolve => {
      const fulfill = () => resolve(this.__setState(this.__states.read));

      this.__stream.once("readable", fulfill);
    }));

    _defineProperty(this, "next",
    /*#__PURE__*/
    _asyncToGenerator(function* () {
      while (true) {
        yield nextTick();

        if (_this.__isErrorState()) {
          throw _this.__error;
        } // Ensure of a Readable ending


        if (_this.__isEndState()) {
          return {
            value: undefined,
            done: true
          };
        } // Set the "readable" event listener (using once method)
        // and wait for the event emitting


        if (_this.__isPendingState()) {
          yield _this.__ensureRead();
          continue;
        }

        const value = _this.__stream.read(); // Back to the "pending" state if given value is nullish


        if (value == null) {
          _this.__setState(_this.__states.pending);

          continue;
        }

        return {
          value,
          done: false
        };
      }
    }));

    this.__stream = stream;
    this.__states = {
      pending: _Symbol("pending"),
      read: _Symbol("read"),
      error: _Symbol("error")
    };
    this.__state = this.__states.pending;
    this.__error = null;

    this.__stream.on("error", this.__onError);
  }

  [_Symbol$asyncIterator]() {
    return this;
  }

}

export default StreamIterator;