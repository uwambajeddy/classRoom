let _Symbol$toStringTag;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import p from "path";
import fs from "fs";
import invariant from "@octetstream/invariant";
import isPlainObject from "./util/isPlainObject";
import isString from "./util/isString";
import getType from "./util/getType";
_Symbol$toStringTag = Symbol.toStringTag;

class File {
  /**
   * Check if given values is a File
   *
   * @param {any} val
   *
   * @return {boolean}
   *
   * @api public
   */
  static isFile(value) {
    return value instanceof File;
  }
  /**
   * File class.
   *
   * @param {object} options
   *
   * @constructor
   *
   * @api public
   */


  constructor(options) {
    _defineProperty(this, "read", () => new Promise((resolve, reject) => {
      const data = [];

      const onReadable = () => {
        const ch = this.contents.read();

        if (ch != null) {
          data.push(ch);
        }
      };

      const onEnd = () => resolve(Buffer.concat(data));

      this.contents.on("error", reject).on("readable", onReadable).on("end", onEnd);
    }));

    _defineProperty(this, "write", path => new Promise((resolve, reject) => {
      if (path && !isString(path)) {
        return reject(new TypeError("Path must be a string."));
      } // Prevent writing file to its source


      if (this.path === path) {
        return resolve();
      }

      this.contents.on("error", reject).on("end", resolve).pipe(fs.createWriteStream(path || this.path));
    }));

    invariant(!isPlainObject(options), TypeError, "File options should be a plain object. Received", getType(options));
    const {
      contents,
      filename,
      enc,
      mime
    } = options;
    invariant(!contents, "File contents required.");
    invariant(!(contents instanceof fs.ReadStream), TypeError, "Contents should be a ReadStream stream. Received %s", getType(contents));
    invariant(!filename, "Filename required.");
    invariant(!isString(filename), TypeError, "Filename should be a string. Received %s", getType(filename));
    invariant(!enc, "File encoding required.");
    invariant(!isString(enc), TypeError, "File encoding should be a string. Received %s", getType(enc));
    invariant(!mime, "File mime type required.");
    invariant(!isString(mime), TypeError, "File mime type should be a string. Received %s", getType(mime));
    const ext = p.extname(filename);
    const base = p.basename(filename, ext);
    this.__contents = contents;
    this.__stream = contents;
    this.__filename = p.basename(filename);
    this.__basename = base;
    this.__extname = ext;
    this.__mime = mime;
    this.__enc = enc; // this.__path = join(tmpdir(), `${nanoid()}_${this.filename}`)

    this.__path = filename;
    this.toJSON = this.toJSON.bind(this);
    this.inspect = this.inspect.bind(this);
  }

  get contents() {
    return this.__contents;
  }

  get stream() {
    return this.__stream;
  }

  get filename() {
    return this.__filename;
  }

  get basename() {
    return this.__basename;
  }

  get extname() {
    return this.__extname;
  }

  get enc() {
    return this.__enc;
  }

  get mime() {
    return this.__mime;
  }

  get path() {
    return this.__path;
  }
  /**
   * Read file contents from a stream
   *
   * @return {Promise<Buffer>}
   */


  get [_Symbol$toStringTag]() {
    return `File: ${this.filename}`;
  }

  toJSON() {
    return `[File: ${this.filename}]`;
  }

  toString() {
    return `[File: ${this.filename}]`;
  }

  inspect() {
    return `[File: ${this.filename}]`;
  }

}

export default File;
export const isFile = File.isFile;