"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFile = exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _fs = _interopRequireDefault(require("fs"));

var _invariant = _interopRequireDefault(require("@octetstream/invariant"));

var _isPlainObject = _interopRequireDefault(require("./util/isPlainObject"));

var _isString = _interopRequireDefault(require("./util/isString"));

var _getType = _interopRequireDefault(require("./util/getType"));

let _Symbol$toStringTag;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

_Symbol$toStringTag = Symbol.toStringTag;

class File {
  /**
   * Check if given values is a File
   *
   * @param {any} val
   *
   * @return {boolean}
   *
   * @api public
   */
  static isFile(value) {
    return value instanceof File;
  }
  /**
   * File class.
   *
   * @param {object} options
   *
   * @constructor
   *
   * @api public
   */


  constructor(options) {
    _defineProperty(this, "read", () => new Promise((resolve, reject) => {
      const data = [];

      const onReadable = () => {
        const ch = this.contents.read();

        if (ch != null) {
          data.push(ch);
        }
      };

      const onEnd = () => resolve(Buffer.concat(data));

      this.contents.on("error", reject).on("readable", onReadable).on("end", onEnd);
    }));

    _defineProperty(this, "write", path => new Promise((resolve, reject) => {
      if (path && !(0, _isString.default)(path)) {
        return reject(new TypeError("Path must be a string."));
      } // Prevent writing file to its source


      if (this.path === path) {
        return resolve();
      }

      this.contents.on("error", reject).on("end", resolve).pipe(_fs.default.createWriteStream(path || this.path));
    }));

    (0, _invariant.default)(!(0, _isPlainObject.default)(options), TypeError, "File options should be a plain object. Received", (0, _getType.default)(options));
    const {
      contents,
      filename,
      enc,
      mime
    } = options;
    (0, _invariant.default)(!contents, "File contents required.");
    (0, _invariant.default)(!(contents instanceof _fs.default.ReadStream), TypeError, "Contents should be a ReadStream stream. Received %s", (0, _getType.default)(contents));
    (0, _invariant.default)(!filename, "Filename required.");
    (0, _invariant.default)(!(0, _isString.default)(filename), TypeError, "Filename should be a string. Received %s", (0, _getType.default)(filename));
    (0, _invariant.default)(!enc, "File encoding required.");
    (0, _invariant.default)(!(0, _isString.default)(enc), TypeError, "File encoding should be a string. Received %s", (0, _getType.default)(enc));
    (0, _invariant.default)(!mime, "File mime type required.");
    (0, _invariant.default)(!(0, _isString.default)(mime), TypeError, "File mime type should be a string. Received %s", (0, _getType.default)(mime));

    const ext = _path.default.extname(filename);

    const base = _path.default.basename(filename, ext);

    this.__contents = contents;
    this.__stream = contents;
    this.__filename = _path.default.basename(filename);
    this.__basename = base;
    this.__extname = ext;
    this.__mime = mime;
    this.__enc = enc; // this.__path = join(tmpdir(), `${nanoid()}_${this.filename}`)

    this.__path = filename;
    this.toJSON = this.toJSON.bind(this);
    this.inspect = this.inspect.bind(this);
  }

  get contents() {
    return this.__contents;
  }

  get stream() {
    return this.__stream;
  }

  get filename() {
    return this.__filename;
  }

  get basename() {
    return this.__basename;
  }

  get extname() {
    return this.__extname;
  }

  get enc() {
    return this.__enc;
  }

  get mime() {
    return this.__mime;
  }

  get path() {
    return this.__path;
  }
  /**
   * Read file contents from a stream
   *
   * @return {Promise<Buffer>}
   */


  get [_Symbol$toStringTag]() {
    return `File: ${this.filename}`;
  }

  toJSON() {
    return `[File: ${this.filename}]`;
  }

  toString() {
    return `[File: ${this.filename}]`;
  }

  inspect() {
    return `[File: ${this.filename}]`;
  }

}

var _default = File;
exports.default = _default;
const isFile = File.isFile;
exports.isFile = isFile;